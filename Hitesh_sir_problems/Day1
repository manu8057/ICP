Problem 1------
Question-->Allocate Minimum Pages(GFG)-->

Soln of problem number 1------>
-------------------------------------------------------
class Solution {
    public int findPages(int[] arr, int k) {
        // code here
        int n=arr.length;
        if(k > n) return -1;
        int l=arr[0];
        int r=0;
        for(int i:arr){
            r+=i;
            if(i>l) l=i;
        }
        int ans=-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            int c=1;
            int sum=0;
            for(int i=0;i<arr.length;i++){
                if(sum+arr[i]>mid){
                    c++;
                    sum=arr[i];
                }
                else{
                    sum+=arr[i];
                }
            }
            if(c<=k){
                ans=mid;
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        return ans;
    }
}

Problem number 2---------------->
Question----->Painter PartitionII (GFG)

soln of problem number 2--->
------------------------------------------

class Solution {
    public int minTime(int[] arr, int k) {
        // code here
        int l=0;
        int r=0;
        for(int i:arr){
            r+=i;
            if(i>l) l=i;
        }
        int ans=-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            int c=1;
            int sum=0;
            for(int i:arr){
                if(sum+i>mid){
                    c++;
                    sum=i;
                }
                else{
                    sum+=i;
                }
            }
            if(c<=k){
                ans=mid;
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        return ans;
    }
}


Problem number 3------------->

Question -------->Minimum Number of Days to Make m Bouquets (Leetcode 1482)--->

solution for problem number 3rd --->

------------------------------------------------------------------------

class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        int l=bloomDay[0];
        int r=0;
        if(m*k>bloomDay.length) return -1;
        for(int i:bloomDay){
            if(i<l) l=i;
            if(i>r) r=i;
        }
        int ans=-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            int c=0;
            int sum=0;
            for(int i=0;i<bloomDay.length;i++){
                if(bloomDay[i]<=mid){
                    c++;
                    if(c==k){
                        sum++;
                        c=0;
                    }
                }
                else{
                    c=0;
                }
            }
            if(sum>=m){
                ans=mid;
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        return ans;
    }
}


Problem number 4---------->

Question ---->   Minimum Speed to Arrive on Time(LeetCode 1870)--->>>>>>>

Solution for problem 4--------------->

--------------------------------------------------------------------------
class Solution {
    public int minSpeedOnTime(int[] dist, double hour) {
        int l = 1;
        int r = 10000000;
        int ans = -1;

        while(l <= r){
            int mid = l + (r - l)/2;
            double sum = 0;

            for(int i = 0; i < dist.length; i++){
                if(i != dist.length - 1){
                    sum += Math.ceil((double)dist[i] / mid);
                } else {
                    sum += (double)dist[i] / mid;
                }
            }

            if(sum <= hour){
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        return ans;
    }
}


