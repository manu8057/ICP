Problem number 1-------------->

Question --->Build Array from Permutation(Leetcode ::1920)-----

Solution for problem number 1--

-----------------------------
class Solution {
    public int[] buildArray(int[] nums) {
        int ans[]=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            ans[i]=nums[nums[i]];
        }
        return ans;
    }
}


Problem number 2-------------->

Question --->Concatenation of Array(Leetcode ::1929)-----

Solution for problem number 2--

-----------------------------
class Solution {
    public int[] getConcatenation(int[] nums) {
        int[] arr=new int[nums.length*2];
        for(int i=0;i<arr.length;i++){
            arr[i]=nums[i%nums.length];
        }
        return arr;
    }
}


Problem number 3-------------->

Question ---> Running Sum of 1d Array(Leetcode ::1480)-----

Solution for problem number 3------>

------------------------------------------
class Solution {
    public int[] runningSum(int[] nums) {
        int sum=0;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
            nums[i]=sum;
        }
        return nums;
    }
}

Problem number 4-------------->

Question --->  Richest Customer Wealth(Leetcode ::1672)-----

Solution for problem number 4------>

----------------------------------
class Solution {
    public int maximumWealth(int[][] accounts) {
        int ans=0;
        for(int i=0;i<accounts.length;i++){
            int sum=0;
            for(int j=0;j<accounts[0].length;j++){
                sum+=accounts[i][j];
            }
            ans=Math.max(ans,sum);
        }
        return ans;
    }
}

Problem number 5-------------->

Question --->  Shuffle the Array(Leetcode ::1470)-----

Solution for problem number 5------>
------------------------------------------------
class Solution {
    public int[] shuffle(int[] nums, int n) {
        int arr[]=new int[n*2];
        int i=0;
        int id=0;
        while(i<n){
            arr[id++]=nums[i];
            arr[id++]=nums[i+n];
            i++;
        }
        return arr;
    }
}


Problem number 7-------------->

Question --->  Next Greater Element I(Leetcode ::496)-----

Solution for problem number 7------>
------------------------------------------------
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int arr[]=new int[nums1.length];
        HashMap<Integer,Integer>map=new HashMap<>();
        Stack<Integer>st=new Stack<>();
        for(int j=nums2.length-1;j>=0;j--){
            while(!st.isEmpty() && st.peek()<nums2[j]){
                st.pop();
            }
            if(st.isEmpty()){
                map.put(nums2[j],-1);
            }
            else{
                map.put(nums2[j],st.peek());
            }
            st.push(nums2[j]);
        }
        for(int i=0;i<nums1.length;i++){
            arr[i]=map.get(nums1[i]);
        }
        return arr;
    }
}

Problem number 8-------------->

Question --->  Next Greater Element I(Leetcode ::229)-----

Solution for problem number 8------>
------------------------------------------------
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer>l=new ArrayList<>();
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        } 
        for(Integer i:map.keySet()){
            if(map.get(i)>nums.length/3){
                l.add(i);
            }
        }
        Collections.sort(l);
        return l;
    }
}


Problem number 8-------------->

Question --->   Product of Array Except Self(Leetcode ::238)-----

Solution for problem number 8------>
------------------------------------------------
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int pro=1;
        int c=0;
        int[] arr=new int[nums.length];
        for(int i:nums){
            if(i==0){
                c++;
                continue;
            }
            pro=pro*i;
        }
        if(c>1) return arr;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0) arr[i]=pro;
            else if(c==1)  arr[i]=0;
            else arr[i]=pro/nums[i];
        }
        return arr;
    }
}

Problem number 9-------------->

Question --->   Find First and Last Position of Element in Sorted Array(Leetcode ::34)-----

Solution for problem number 9------>
------------------------------------------------
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res=new int[2];
        res[0]=-1;
        res[1]=-1;
        int l=0;
        int r=nums.length-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            if(nums[mid]==target){
                res[0]=mid;
                r=mid-1;
            }
            else if(nums[mid]<target){
                l++;
            }
            else{
                r--;
            }
        }
        if(res[0]==-1) return res;
        l=0;
        r=nums.length-1;
         while(l<=r){
            int mid=l+(r-l)/2;
            if(nums[mid]==target){
                res[1]=mid;
                l=mid+1;
            }
            else if(nums[mid]<target){
                l++;
            }
            else{
                r--;
            }
        }
        return res;
    }
}

Problem number 10-------------->

Question --->   Rotate Array(Leetcode ::189)-----

Solution for problem number 10------>
------------------------------------------------
class Solution {
    public void fun(int[] nums, int l, int r){
        while(l < r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        fun(nums, 0, n-1);
        fun(nums, 0, k-1);
        fun(nums, k, n-1);
    }

}

Problem number 11-------------->

Question --->   Rotate Array(Leetcode ::189)-----

Solution for problem number 11------>
------------------------------------------------







