Problem number 1->House Robber(LeetCode 198)--------------------->
------------------------------------------------------------------------------------->
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        int max=Math.max(nums[0],nums[1]);
        nums[1]=max;
        if(nums.length==2) return max;
        for(int i=2;i<nums.length;i++){
            nums[i]=Math.max(nums[i-1],nums[i]+nums[i-2]);
        }
        return nums[nums.length-1];
    }
}



Problem number 2---------------->Maximum Subarray(Leetcode 53)---->
------------------------------------------------------------------------
class Solution {
    public int maxSubArray(int[] nums) {
        int sum=0;
        int max=Integer.MIN_VALUE;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
            max=Math.max(max,sum);
            if(sum<0){
                sum=0;
            }
        }
        return max;
    }
}


Problem number 3------------------>Unique Paths(LeetCode 62)---->
-------------------------------------------------------------------->
class Solution {
    public int fun(int[][] arr,int r,int c,int m,int n,int dp[][]){
        if(c==n-1 && r==m-1){
            return 1;
        }
        if(c>=n || r>=m){
            return 0;
        }
        if(dp[r][c]!=0){
            return dp[r][c];
        }
        int count=0;
        count+=fun(arr,r,c+1,m,n,dp);
        count+=fun(arr,r+1,c,m,n,dp);
        dp[r][c]=count;
        return count;

    }
    public int uniquePaths(int m, int n) {
        int[][] arr=new int[m][n];
        int[][] dp=new int[m][n];
        return fun(arr,0,0,m,n,dp);
    }
}